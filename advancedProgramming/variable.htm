<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>变量</title>
</head>
<body>
</body>
<script>
    //引用类型添加属性和方法
    /* var person = new Object();
    person.name = "jack";
    console.log(person.name);   // "jack"
    //为该对象添加一个name属性并赋值，后输出。如果对象不被销毁或者删除，则一直存在

    //基本类型不能添加属性，尽管不会导致错误
    var name = "jack";
    name.age = 22;
    console.log(name.age);  //undefined


    // 基本类型复制的值是独立的
    var num1 = 5;
    var num2 = num1; */


    //两个变量实际上引用同一个对象。因此，改变其中一个变量，就会影响另一个变量
   /*  var obj1 = new Object();
    var obj2 = obj1;
    obj1.name = "jack";
    console.log(obj2.name); */


    // 传递参数
    // 向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数)
    /* function add(num){
        num += 10;
        return num;
    }
    var count = 20;
    var result = add(count);
    console.log(count); // 20
    console.log(result);  // 30 */
    // 在函数内部，num的值加10，但不会影响函数外部的count变量


    // 向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部
    /* function setName(obj){
        obj.name = "ccc";
    }
    var person = new Object();
    setName(person);
    console.log(person.name); // ccc */
    //即使person这个变量是按值传递的，obj也会按引用来访问同一个对象


    // 证明对象是按值传递的
    /* function setName1(obj){
        obj.name = "ccc";
        obj = new Object();     // 当函数内部重写 obj 时，这个变量引用的就是一个局部对象，会在函数执行完立即销毁
        obj.name = "cherry";
    }
    var person = new Object();
    setName(person);
    console.log(person.name);   // ccc
 */

    // 检测类型
    /* var person = new Object();
    console.log(person instanceof Object);

    var colors = [1,2,3];
    console.log(colors instanceof Array);

    var pattern = new RegExp(); 
    console.log(pattern instanceof RegExp);
    //如果变量是给定引用类型的实例，返回true */


    //作用域链【搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符。(找不到就报错)】
    /*  var color = "blue";
     function changeColor(){
         if(color === "blue"){  //之所以可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它
            color = "red";
         }else{
             color = "green";
         }
     }
     changeColor();
     console.log("color is now " + color); */


     // 在局部作用域中定义的变量可以在局部环境中与全局变量互换使用
     /* var color = "blue";
     function changeColor(){
         var anotherColor = "red";
         function swapColors(){
             var tempColor = anotherColor;
             anotherColor = color;
             color = tempColor;
             //这里可以访问color, anotherColor, tempColor
         }
         swapColors();  //这里可以访问color, anotherColor, 但不能访问 tempColor
     }
     changeColor();     // 这里只能访问 color
     console.log("color is now " + color); */

     
</script>
</html>